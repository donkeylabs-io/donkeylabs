// Auto-generated by @donkeylabs/server
// DO NOT EDIT MANUALLY

import { UnifiedApiClientBase, type ClientOptions } from "@donkeylabs/adapter-sveltekit/client";

// Utility type that forces TypeScript to expand types on hover
type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;

/**
 * Handler interface for implementing route handlers in model classes.
 * @example
 * class CounterModel implements Handler<Routes.Counter.get> {
 *   handle(input: Routes.Counter.get.Input): Routes.Counter.get.Output {
 *     return { count: 0 };
 *   }
 * }
 */
export interface Handler<T extends { Input: any; Output: any }> {
  handle(input: T["Input"]): T["Output"] | Promise<T["Output"]>;
}

// Re-export server context for model classes
export { type ServerContext as AppContext } from "@donkeylabs/server";

// ============================================
// Route Types
// ============================================

export namespace Routes {
  export namespace Api {
    export namespace Counter {
      export namespace Get {
        export type Input = Expand<Record<string, never>>;
        export type Output = Expand<{
  count: number;
}>;
      }
      export type Get = { Input: Get.Input; Output: Get.Output };

      export namespace Increment {
        export type Input = Expand<Record<string, never>>;
        export type Output = Expand<{
  count: number;
}>;
      }
      export type Increment = { Input: Increment.Input; Output: Increment.Output };

      export namespace Decrement {
        export type Input = Expand<Record<string, never>>;
        export type Output = Expand<{
  count: number;
}>;
      }
      export type Decrement = { Input: Decrement.Input; Output: Decrement.Output };

      export namespace Reset {
        export type Input = Expand<Record<string, never>>;
        export type Output = Expand<{
  count: number;
}>;
      }
      export type Reset = { Input: Reset.Input; Output: Reset.Output };
    }

    export namespace Cache {
      export namespace Set {
        export type Input = Expand<{
  key: string;
  value: any;
  ttl?: number;
}>;
        export type Output = Expand<{
  success: boolean;
}>;
      }
      export type Set = { Input: Set.Input; Output: Set.Output };

      export namespace Get {
        export type Input = Expand<{
  key: string;
}>;
        export type Output = Expand<{
  value?: any;
  exists: boolean;
}>;
      }
      export type Get = { Input: Get.Input; Output: Get.Output };

      export namespace Delete {
        export type Input = Expand<{
  key: string;
}>;
        export type Output = Expand<{
  success: boolean;
}>;
      }
      export type Delete = { Input: Delete.Input; Output: Delete.Output };

      export namespace Keys {
        export type Input = Expand<Record<string, never>>;
        export type Output = Expand<{
  keys: string[];
  size: number;
}>;
      }
      export type Keys = { Input: Keys.Input; Output: Keys.Output };
    }

    export namespace Sse {
      export namespace Broadcast {
        export type Input = Expand<{
  channel: string;
  event: string;
  data: any;
}>;
        export type Output = Expand<{
  success: boolean;
}>;
      }
      export type Broadcast = { Input: Broadcast.Input; Output: Broadcast.Output };

      export namespace Clients {
        export type Input = Expand<Record<string, never>>;
        export type Output = Expand<{
  total: number;
  byChannel: number;
}>;
      }
      export type Clients = { Input: Clients.Input; Output: Clients.Output };
    }

    export namespace Jobs {
      export namespace Enqueue {
        export type Input = Expand<{
  name: string;
  data?: Record<string, any>;
  delay?: number;
}>;
        export type Output = Expand<{
  jobId: string;
}>;
      }
      export type Enqueue = { Input: Enqueue.Input; Output: Enqueue.Output };

      export namespace Stats {
        export type Input = Expand<Record<string, never>>;
        export type Output = Expand<{
  pending: number;
  running: number;
  completed: number;
}>;
      }
      export type Stats = { Input: Stats.Input; Output: Stats.Output };
    }

    export namespace Events {
      export namespace Emit {
        export type Input = Expand<{
  event: string;
  data?: Record<string, any>;
}>;
        export type Output = Expand<{
  success: boolean;
}>;
      }
      export type Emit = { Input: Emit.Input; Output: Emit.Output };
    }

    export namespace Ratelimit {
      export namespace Check {
        export type Input = Expand<{
  key: string;
  limit: number;
  window: number;
}>;
        export type Output = Expand<{
  allowed: boolean;
  remaining: number;
  limit: number;
  resetAt: Date;
}>;
      }
      export type Check = { Input: Check.Input; Output: Check.Output };

      export namespace Reset {
        export type Input = Expand<{
  key: string;
}>;
        export type Output = Expand<{
  success: boolean;
}>;
      }
      export type Reset = { Input: Reset.Input; Output: Reset.Output };
    }

    export namespace Cron {
      export namespace List {
        export type Input = Expand<Record<string, never>>;
        export type Output = Expand<{
  tasks: {
  id: string;
  name: string;
  expression: string;
  enabled: boolean;
  lastRun?: string;
  nextRun?: string;
}[];
}>;
      }
      export type List = { Input: List.Input; Output: List.Output };
    }

    export namespace Workflow {
      export namespace Start {
        export type Input = Expand<{
  orderId: string;
  items: {
  name: string;
  qty: number;
}[];
  customerEmail: string;
}>;
        export type Output = Expand<{
  instanceId: string;
}>;
      }
      export type Start = { Input: Start.Input; Output: Start.Output };

      export namespace Status {
        export type Input = Expand<{
  instanceId: string;
}>;
        export type Output = Expand<{
  id: string;
  status: string;
  currentStep?: string;
  input: any;
  output?: any;
  error?: string;
  stepResults: Record<string, any>;
  createdAt: string;
  startedAt?: string;
  completedAt?: string;
} | null>;
      }
      export type Status = { Input: Status.Input; Output: Status.Output };

      export namespace List {
        export type Input = Expand<{
  status?: string;
}>;
        export type Output = Expand<{
  instances: {
  id: string;
  status: string;
  currentStep?: string;
  createdAt: string;
  completedAt?: string;
}[];
}>;
      }
      export type List = { Input: List.Input; Output: List.Output };

      export namespace Cancel {
        export type Input = Expand<{
  instanceId: string;
}>;
        export type Output = Expand<{
  success: boolean;
}>;
      }
      export type Cancel = { Input: Cancel.Input; Output: Cancel.Output };
    }
  }
}

// ============================================
// API Client
// ============================================

export class ApiClient extends UnifiedApiClientBase {
  constructor(options?: ClientOptions) {
    super(options);
  }

  api = {
    counter: {
      get: (input: Routes.Api.Counter.Get.Input): Promise<Routes.Api.Counter.Get.Output> => this.request("api.counter.get", input),
      increment: (input: Routes.Api.Counter.Increment.Input): Promise<Routes.Api.Counter.Increment.Output> => this.request("api.counter.increment", input),
      decrement: (input: Routes.Api.Counter.Decrement.Input): Promise<Routes.Api.Counter.Decrement.Output> => this.request("api.counter.decrement", input),
      reset: (input: Routes.Api.Counter.Reset.Input): Promise<Routes.Api.Counter.Reset.Output> => this.request("api.counter.reset", input)
    },
    cache: {
      set: (input: Routes.Api.Cache.Set.Input): Promise<Routes.Api.Cache.Set.Output> => this.request("api.cache.set", input),
      get: (input: Routes.Api.Cache.Get.Input): Promise<Routes.Api.Cache.Get.Output> => this.request("api.cache.get", input),
      delete: (input: Routes.Api.Cache.Delete.Input): Promise<Routes.Api.Cache.Delete.Output> => this.request("api.cache.delete", input),
      keys: (input: Routes.Api.Cache.Keys.Input): Promise<Routes.Api.Cache.Keys.Output> => this.request("api.cache.keys", input)
    },
    sse: {
      broadcast: (input: Routes.Api.Sse.Broadcast.Input): Promise<Routes.Api.Sse.Broadcast.Output> => this.request("api.sse.broadcast", input),
      clients: (input: Routes.Api.Sse.Clients.Input): Promise<Routes.Api.Sse.Clients.Output> => this.request("api.sse.clients", input)
    },
    jobs: {
      enqueue: (input: Routes.Api.Jobs.Enqueue.Input): Promise<Routes.Api.Jobs.Enqueue.Output> => this.request("api.jobs.enqueue", input),
      stats: (input: Routes.Api.Jobs.Stats.Input): Promise<Routes.Api.Jobs.Stats.Output> => this.request("api.jobs.stats", input)
    },
    events: {
      emit: (input: Routes.Api.Events.Emit.Input): Promise<Routes.Api.Events.Emit.Output> => this.request("api.events.emit", input)
    },
    ratelimit: {
      check: (input: Routes.Api.Ratelimit.Check.Input): Promise<Routes.Api.Ratelimit.Check.Output> => this.request("api.ratelimit.check", input),
      reset: (input: Routes.Api.Ratelimit.Reset.Input): Promise<Routes.Api.Ratelimit.Reset.Output> => this.request("api.ratelimit.reset", input)
    },
    cron: {
      list: (input: Routes.Api.Cron.List.Input): Promise<Routes.Api.Cron.List.Output> => this.request("api.cron.list", input)
    },
    workflow: {
      start: (input: Routes.Api.Workflow.Start.Input): Promise<Routes.Api.Workflow.Start.Output> => this.request("api.workflow.start", input),
      status: (input: Routes.Api.Workflow.Status.Input): Promise<Routes.Api.Workflow.Status.Output> => this.request("api.workflow.status", input),
      list: (input: Routes.Api.Workflow.List.Input): Promise<Routes.Api.Workflow.List.Output> => this.request("api.workflow.list", input),
      cancel: (input: Routes.Api.Workflow.Cancel.Input): Promise<Routes.Api.Workflow.Cancel.Output> => this.request("api.workflow.cancel", input)
    }
  };
}

/**
 * Create an API client instance
 */
export function createApi(options?: ClientOptions) {
  return new ApiClient(options);
}
