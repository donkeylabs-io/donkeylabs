// Auto-generated by donkeylabs generate
// DO NOT EDIT MANUALLY

import { UnifiedApiClientBase, SSEConnection, type ClientOptions } from "@donkeylabs/adapter-sveltekit/client";

// Utility type that forces TypeScript to expand types on hover
type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;

// ============================================
// Route Types
// ============================================

export namespace Routes {
  export namespace Counter {
    export namespace Get {
      export type Input = Expand<Record<string, never>>;
      export type Output = Expand<{
  count: number;
}>;
    }
    export type Get = { Input: Get.Input; Output: Get.Output };

    export namespace Increment {
      export type Input = Expand<Record<string, never>>;
      export type Output = Expand<{
  count: number;
}>;
    }
    export type Increment = { Input: Increment.Input; Output: Increment.Output };

    export namespace Decrement {
      export type Input = Expand<Record<string, never>>;
      export type Output = Expand<{
  count: number;
}>;
    }
    export type Decrement = { Input: Decrement.Input; Output: Decrement.Output };

    export namespace Reset {
      export type Input = Expand<Record<string, never>>;
      export type Output = Expand<{
  count: number;
}>;
    }
    export type Reset = { Input: Reset.Input; Output: Reset.Output };
  }

  export namespace Cache {
    export namespace Set {
      export type Input = Expand<{
  key: string;
  value: any;
  ttl?: number;
}>;
      export type Output = Expand<{
  success: boolean;
}>;
    }
    export type Set = { Input: Set.Input; Output: Set.Output };

    export namespace Get {
      export type Input = Expand<{
  key: string;
}>;
      export type Output = Expand<{
  value?: any;
  exists: boolean;
}>;
    }
    export type Get = { Input: Get.Input; Output: Get.Output };

    export namespace Delete {
      export type Input = Expand<{
  key: string;
}>;
      export type Output = Expand<{
  success: boolean;
}>;
    }
    export type Delete = { Input: Delete.Input; Output: Delete.Output };

    export namespace Keys {
      export type Input = Expand<Record<string, never>>;
      export type Output = Expand<{
  keys: string[];
  size: number;
}>;
    }
    export type Keys = { Input: Keys.Input; Output: Keys.Output };
  }

  export namespace Sse {
    export namespace Broadcast {
      export type Input = Expand<{
  channel: string;
  event: string;
  data: any;
}>;
      export type Output = Expand<{
  success: boolean;
}>;
    }
    export type Broadcast = { Input: Broadcast.Input; Output: Broadcast.Output };

    export namespace Clients {
      export type Input = Expand<Record<string, never>>;
      export type Output = Expand<{
  total: number;
  byChannel: number;
}>;
    }
    export type Clients = { Input: Clients.Input; Output: Clients.Output };
  }

  export namespace Jobs {
    export namespace Enqueue {
      export type Input = Expand<{
  name: string;
  data?: Record<string, any>;
  delay?: number;
}>;
      export type Output = Expand<{
  jobId: string;
}>;
    }
    export type Enqueue = { Input: Enqueue.Input; Output: Enqueue.Output };

    export namespace Stats {
      export type Input = Expand<Record<string, never>>;
      export type Output = Expand<{
  pending: number;
  running: number;
  completed: number;
}>;
    }
    export type Stats = { Input: Stats.Input; Output: Stats.Output };
  }

  export namespace Events {
    export namespace Emit {
      export type Input = Expand<{
  event: string;
  data?: Record<string, any>;
}>;
      export type Output = Expand<{
  success: boolean;
}>;
    }
    export type Emit = { Input: Emit.Input; Output: Emit.Output };
  }

  export namespace Ratelimit {
    export namespace Check {
      export type Input = Expand<{
  key: string;
  limit: number;
  window: number;
}>;
      export type Output = Expand<{
  allowed: boolean;
  remaining: number;
  limit: number;
  resetAt: Date;
}>;
    }
    export type Check = { Input: Check.Input; Output: Check.Output };

    export namespace Reset {
      export type Input = Expand<{
  key: string;
}>;
      export type Output = Expand<{
  success: boolean;
}>;
    }
    export type Reset = { Input: Reset.Input; Output: Reset.Output };
  }

  export namespace Cron {
    export namespace List {
      export type Input = Expand<Record<string, never>>;
      export type Output = Expand<{
  tasks: {
  id: string;
  name: string;
  expression: string;
  enabled: boolean;
  lastRun?: string;
  nextRun?: string;
}[];
}>;
    }
    export type List = { Input: List.Input; Output: List.Output };
  }

  export namespace Workflow {
    export namespace Start {
      export type Input = Expand<{
  orderId: string;
  items: {
  name: string;
  qty: number;
}[];
  customerEmail: string;
}>;
      export type Output = Expand<{
  instanceId: string;
}>;
    }
    export type Start = { Input: Start.Input; Output: Start.Output };

    export namespace Status {
      export type Input = Expand<{
  instanceId: string;
}>;
      export type Output = Expand<{
  id: string;
  status: string;
  currentStep?: string;
  input: any;
  output?: any;
  error?: string;
  stepResults: Record<string, any>;
  createdAt: string;
  startedAt?: string;
  completedAt?: string;
} | null>;
    }
    export type Status = { Input: Status.Input; Output: Status.Output };

    export namespace List {
      export type Input = Expand<{
  status?: string;
}>;
      export type Output = Expand<{
  instances: {
  id: string;
  status: string;
  currentStep?: string;
  createdAt: string;
  completedAt?: string;
}[];
}>;
    }
    export type List = { Input: List.Input; Output: List.Output };

    export namespace Cancel {
      export type Input = Expand<{
  instanceId: string;
}>;
      export type Output = Expand<{
  success: boolean;
}>;
    }
    export type Cancel = { Input: Cancel.Input; Output: Cancel.Output };
  }

  export namespace Audit {
    export namespace Log {
      export type Input = Expand<{
  action: string;
  resource: string;
  resourceId?: string;
  metadata?: Record<string, any>;
}>;
      export type Output = Expand<{
  id: string;
}>;
    }
    export type Log = { Input: Log.Input; Output: Log.Output };

    export namespace Query {
      export type Input = Expand<{
  action?: string;
  resource?: string;
  limit: number;
}>;
      export type Output = Expand<{
  entries: {
  id: string;
  timestamp: string;
  action: string;
  actor: string;
  resource: string;
  resourceId?: string;
  metadata?: Record<string, any>;
}[];
}>;
    }
    export type Query = { Input: Query.Input; Output: Query.Output };

    export namespace ByResource {
      export type Input = Expand<{
  resource: string;
  resourceId: string;
}>;
      export type Output = Expand<{
  entries: {
  id: string;
  timestamp: string;
  action: string;
  actor: string;
  metadata?: Record<string, any>;
}[];
}>;
    }
    export type ByResource = { Input: ByResource.Input; Output: ByResource.Output };
  }

  export namespace Websocket {
    export namespace Broadcast {
      export type Input = Expand<{
  channel: string;
  event: string;
  data: any;
}>;
      export type Output = Expand<{
  success: boolean;
}>;
    }
    export type Broadcast = { Input: Broadcast.Input; Output: Broadcast.Output };

    export namespace BroadcastAll {
      export type Input = Expand<{
  event: string;
  data: any;
}>;
      export type Output = Expand<{
  success: boolean;
}>;
    }
    export type BroadcastAll = { Input: BroadcastAll.Input; Output: BroadcastAll.Output };

    export namespace Clients {
      export type Input = Expand<{
  channel?: string;
}>;
      export type Output = Expand<{
  count: number;
  clients: string[];
}>;
    }
    export type Clients = { Input: Clients.Input; Output: Clients.Output };

    export namespace ClientCount {
      export type Input = Expand<{
  channel?: string;
}>;
      export type Output = Expand<{
  count: number;
}>;
    }
    export type ClientCount = { Input: ClientCount.Input; Output: ClientCount.Output };
  }
}

// ============================================
// API Client
// ============================================

export class ApiClient extends UnifiedApiClientBase {
  constructor(options?: ClientOptions) {
    super(options);
  }

  counter = {
    get: (input: Routes.Counter.Get.Input): Promise<Routes.Counter.Get.Output> => this.request("api.counter.get", input),
    increment: (input: Routes.Counter.Increment.Input): Promise<Routes.Counter.Increment.Output> => this.request("api.counter.increment", input),
    decrement: (input: Routes.Counter.Decrement.Input): Promise<Routes.Counter.Decrement.Output> => this.request("api.counter.decrement", input),
    reset: (input: Routes.Counter.Reset.Input): Promise<Routes.Counter.Reset.Output> => this.request("api.counter.reset", input)
  };

  cache = {
    set: (input: Routes.Cache.Set.Input): Promise<Routes.Cache.Set.Output> => this.request("api.cache.set", input),
    get: (input: Routes.Cache.Get.Input): Promise<Routes.Cache.Get.Output> => this.request("api.cache.get", input),
    delete: (input: Routes.Cache.Delete.Input): Promise<Routes.Cache.Delete.Output> => this.request("api.cache.delete", input),
    keys: (input: Routes.Cache.Keys.Input): Promise<Routes.Cache.Keys.Output> => this.request("api.cache.keys", input)
  };

  sse = {
    broadcast: (input: Routes.Sse.Broadcast.Input): Promise<Routes.Sse.Broadcast.Output> => this.request("api.sse.broadcast", input),
    clients: (input: Routes.Sse.Clients.Input): Promise<Routes.Sse.Clients.Output> => this.request("api.sse.clients", input)
  };

  jobs = {
    enqueue: (input: Routes.Jobs.Enqueue.Input): Promise<Routes.Jobs.Enqueue.Output> => this.request("api.jobs.enqueue", input),
    stats: (input: Routes.Jobs.Stats.Input): Promise<Routes.Jobs.Stats.Output> => this.request("api.jobs.stats", input)
  };

  events = {
    emit: (input: Routes.Events.Emit.Input): Promise<Routes.Events.Emit.Output> => this.request("api.events.emit", input)
  };

  ratelimit = {
    check: (input: Routes.Ratelimit.Check.Input): Promise<Routes.Ratelimit.Check.Output> => this.request("api.ratelimit.check", input),
    reset: (input: Routes.Ratelimit.Reset.Input): Promise<Routes.Ratelimit.Reset.Output> => this.request("api.ratelimit.reset", input)
  };

  cron = {
    list: (input: Routes.Cron.List.Input): Promise<Routes.Cron.List.Output> => this.request("api.cron.list", input)
  };

  workflow = {
    start: (input: Routes.Workflow.Start.Input): Promise<Routes.Workflow.Start.Output> => this.request("api.workflow.start", input),
    status: (input: Routes.Workflow.Status.Input): Promise<Routes.Workflow.Status.Output> => this.request("api.workflow.status", input),
    list: (input: Routes.Workflow.List.Input): Promise<Routes.Workflow.List.Output> => this.request("api.workflow.list", input),
    cancel: (input: Routes.Workflow.Cancel.Input): Promise<Routes.Workflow.Cancel.Output> => this.request("api.workflow.cancel", input)
  };

  audit = {
    log: (input: Routes.Audit.Log.Input): Promise<Routes.Audit.Log.Output> => this.request("api.audit.log", input),
    query: (input: Routes.Audit.Query.Input): Promise<Routes.Audit.Query.Output> => this.request("api.audit.query", input),
    byResource: (input: Routes.Audit.ByResource.Input): Promise<Routes.Audit.ByResource.Output> => this.request("api.audit.byResource", input)
  };

  websocket = {
    broadcast: (input: Routes.Websocket.Broadcast.Input): Promise<Routes.Websocket.Broadcast.Output> => this.request("api.websocket.broadcast", input),
    broadcastAll: (input: Routes.Websocket.BroadcastAll.Input): Promise<Routes.Websocket.BroadcastAll.Output> => this.request("api.websocket.broadcastAll", input),
    clients: (input: Routes.Websocket.Clients.Input): Promise<Routes.Websocket.Clients.Output> => this.request("api.websocket.clients", input),
    clientCount: (input: Routes.Websocket.ClientCount.Input): Promise<Routes.Websocket.ClientCount.Output> => this.request("api.websocket.clientCount", input)
  };
}

/**
 * Create an API client instance
 *
 * @param options.locals - Pass SvelteKit locals for SSR direct calls (no HTTP overhead)
 * @param options.baseUrl - Override the base URL for HTTP calls
 *
 * @example SSR usage in +page.server.ts:
 * ```ts
 * export const load = async ({ locals }) => {
 *   const api = createApi({ locals });
 *   const data = await api.myRoute.get({}); // Direct call, no HTTP!
 *   return { data };
 * };
 * ```
 *
 * @example Browser usage in +page.svelte:
 * ```svelte
 * <script>
 *   import { createApi } from '$lib/api';
 *   const api = createApi(); // HTTP calls
 *   let data = $state(null);
 *   async function load() {
 *     data = await api.myRoute.get({});
 *   }
 * </script>
 * ```
 */
export function createApi(options?: ClientOptions) {
  return new ApiClient(options);
}
