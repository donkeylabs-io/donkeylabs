/**
 * @donkeylabs/adapter-sveltekit
 *
 * SvelteKit adapter that integrates with @donkeylabs/server.
 * - Single Bun process serves both SvelteKit pages and API routes
 * - Direct service calls during SSR (no HTTP overhead)
 * - Unified API client works in both SSR and browser
 */

import type { Adapter, Builder } from "@sveltejs/kit";
import { fileURLToPath } from "node:url";
import { dirname, join, relative, resolve } from "node:path";
import { writeFileSync, mkdirSync } from "node:fs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export interface AdapterOptions {
  /**
   * Output directory for the built app.
   * @default "build"
   */
  out?: string;

  /**
   * Path to your @donkeylabs/server entry file.
   * This file should export a configured AppServer instance.
   *
   * @default "./src/server/index.ts"
   */
  serverEntry?: string;

  /**
   * Whether to precompress static assets with gzip/brotli.
   * @default true
   */
  precompress?: boolean;

  /**
   * Environment variable prefix for PORT and HOST.
   * @default ""
   */
  envPrefix?: string;

  /**
   * Enable development mode features.
   * @default false
   */
  development?: boolean;
}

export default function adapter(options: AdapterOptions = {}): Adapter {
  const {
    out = "build",
    serverEntry = "./src/server/index.ts",
    precompress = true,
    envPrefix = "",
    development = false,
  } = options;

  return {
    name: "@donkeylabs/adapter-sveltekit",

    async adapt(builder: Builder) {
      const serverDir = join(out, "server");
      const clientDir = join(out, "client");
      const prerenderedDir = join(out, "prerendered");

      // 1. Clean and create output directories
      builder.rimraf(out);
      mkdirSync(serverDir, { recursive: true });

      builder.log.minor("Writing SvelteKit server files...");

      // 2. Write SvelteKit server files
      builder.writeServer(serverDir);

      // 3. Copy static assets and prerendered pages
      const clientFiles = builder.writeClient(clientDir);
      const prerenderedFiles = builder.writePrerendered(prerenderedDir);

      // 4. Generate the manifest
      const relativePath = relative(serverDir, ".");
      builder.generateManifest({ relativePath });

      // 5. Generate the unified runtime entry point
      const serverEntryResolved = resolve(serverEntry);
      const serverEntryRelative = relative(serverDir, serverEntryResolved);

      const entryCode = generateEntryPoint({
        serverEntryRelative,
        envPrefix,
        development,
        clientDir: relative(serverDir, clientDir),
        prerenderedDir: relative(serverDir, prerenderedDir),
      });

      writeFileSync(join(serverDir, "entry.js"), entryCode);

      // 6. Write runtime handler (inline the full implementation)
      writeFileSync(join(serverDir, "handler.js"), generateRuntimeHandler());

      // 7. Precompress if enabled
      if (precompress) {
        builder.log.minor("Compressing assets...");
        await builder.compress(clientDir);
        if (prerenderedFiles.length > 0) {
          await builder.compress(prerenderedDir);
        }
      }

      builder.log.success(`Adapter output written to ${out}`);
      builder.log.minor(`Run with: bun ${out}/server/entry.js`);
    },
  };
}

function generateEntryPoint(config: {
  serverEntryRelative: string;
  envPrefix: string;
  development: boolean;
  clientDir: string;
  prerenderedDir: string;
}): string {
  const { serverEntryRelative, envPrefix, development, clientDir, prerenderedDir } = config;

  return `// Generated by @donkeylabs/adapter-sveltekit
import { Server } from "./index.js";
import { manifest } from "./manifest.js";
import { createUnifiedServer } from "./handler.js";

// Import user's @donkeylabs/server setup
const serverModule = await import("${serverEntryRelative}");
const donkeylabsServer = serverModule.server || serverModule.default;

if (!donkeylabsServer) {
  throw new Error(
    "@donkeylabs/adapter-sveltekit: Could not find server export. " +
    "Make sure your server entry file exports 'server' or uses default export."
  );
}

// Initialize @donkeylabs/server (migrations, plugins, routes)
await donkeylabsServer.initialize();

// Create SvelteKit server
const svelteServer = new Server(manifest);
await svelteServer.init({ env: process.env });

// Configuration
const port = Number(process.env.${envPrefix}PORT) || 3000;
const host = process.env.${envPrefix}HOST || "0.0.0.0";
const development = ${development} || process.env.NODE_ENV === "development";

// Start unified server
createUnifiedServer({
  svelteServer,
  donkeylabsServer,
  port,
  host,
  clientDir: "${clientDir}",
  prerenderedDir: "${prerenderedDir}",
  development,
});

console.log(\`Server running at http://\${host}:\${port}\`);
`;
}

function generateRuntimeHandler(): string {
  // Inline the full runtime handler implementation
  return `// Generated runtime handler by @donkeylabs/adapter-sveltekit
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));

/**
 * Create a unified Bun server that handles both SvelteKit and @donkeylabs/server requests.
 */
export function createUnifiedServer(config) {
  const {
    svelteServer,
    donkeylabsServer,
    port,
    host,
    clientDir: clientDirRelative,
    prerenderedDir: prerenderedDirRelative,
    development = false,
  } = config;

  // Resolve paths relative to this script's directory
  const clientDir = resolve(__dirname, clientDirRelative);
  const prerenderedDir = resolve(__dirname, prerenderedDirRelative);

  // Get services and core from @donkeylabs/server for injection into SvelteKit
  const services = donkeylabsServer.getServices();
  const core = donkeylabsServer.getCore();

  Bun.serve({
    port,
    hostname: host,

    async fetch(req, server) {
      const url = new URL(req.url);
      const pathname = url.pathname;
      const ip = extractClientIP(req, server.requestIP(req)?.address);

      // 1. Handle CORS preflight for API routes
      if (req.method === "OPTIONS") {
        return new Response(null, {
          status: 204,
          headers: getCorsHeaders(),
        });
      }

      // 2. API routes (GET or POST - stream/html/sse use GET, typed uses POST)
      if ((req.method === "GET" || req.method === "POST") && /^\\/[a-zA-Z][a-zA-Z0-9_.]*$/.test(pathname)) {
        const routeName = pathname.slice(1); // Remove leading /

        // Check if this is a registered API route
        if (donkeylabsServer.hasRoute(routeName)) {
          const response = await donkeylabsServer.handleRequest(req, routeName, ip, {
            corsHeaders: getCorsHeaders(),
          });
          if (response) return response;
        }
      }

      // 3. SSE endpoint
      if (pathname === "/sse" && req.method === "GET") {
        return handleSSE(req, core, ip);
      }

      // 4. Static assets (/_app/*, etc.)
      if (isStaticAsset(pathname)) {
        const staticResponse = await serveStatic(clientDir, pathname);
        if (staticResponse) return staticResponse;
      }

      // 5. Prerendered pages
      const prerenderedResponse = await servePrerendered(prerenderedDir, pathname);
      if (prerenderedResponse) return prerenderedResponse;

      // 6. SvelteKit pages
      return handleSvelteKit(req, svelteServer, {
        services,
        core,
        ip,
        donkeylabsServer,
      });
    },
  });
}

function isStaticAsset(pathname) {
  return (
    pathname.startsWith("/_app/") ||
    pathname.startsWith("/static/") ||
    pathname === "/favicon.ico" ||
    pathname === "/robots.txt" ||
    pathname === "/sitemap.xml" ||
    /\\.(js|css|png|jpg|jpeg|gif|svg|ico|woff|woff2|ttf|eot|webp|avif|json|webmanifest)$/.test(pathname)
  );
}

async function serveStatic(clientDir, pathname) {
  const filePath = clientDir + pathname;
  const file = Bun.file(filePath);

  if (await file.exists()) {
    // Check for precompressed versions
    const brFile = Bun.file(filePath + ".br");
    const gzFile = Bun.file(filePath + ".gz");

    if (await brFile.exists()) {
      return new Response(brFile, {
        headers: {
          "Content-Type": file.type || "application/octet-stream",
          "Content-Encoding": "br",
          "Cache-Control": "public, max-age=31536000, immutable",
        },
      });
    }

    if (await gzFile.exists()) {
      return new Response(gzFile, {
        headers: {
          "Content-Type": file.type || "application/octet-stream",
          "Content-Encoding": "gzip",
          "Cache-Control": "public, max-age=31536000, immutable",
        },
      });
    }

    return new Response(file, {
      headers: {
        "Content-Type": file.type || "application/octet-stream",
        "Cache-Control": "public, max-age=31536000, immutable",
      },
    });
  }

  return null;
}

async function servePrerendered(prerenderedDir, pathname) {
  let filePath = prerenderedDir + pathname;
  if (!pathname.endsWith(".html") && !pathname.includes(".")) {
    filePath = prerenderedDir + (pathname === "/" ? "/index" : pathname) + ".html";
  }

  const file = Bun.file(filePath);
  if (await file.exists()) {
    return new Response(file, {
      headers: {
        "Content-Type": "text/html",
        "Cache-Control": "public, max-age=0, must-revalidate",
      },
    });
  }

  return null;
}

async function handleSvelteKit(req, svelteServer, context) {
  return svelteServer.respond(req, {
    getClientAddress: () => context.ip,
    platform: {
      donkeylabs: {
        services: context.services,
        core: context.core,
        // Direct route handler for SSR API calls (no HTTP!)
        handleRoute: async (routeName, input) => {
          return context.donkeylabsServer.callRoute(routeName, input, context.ip);
        },
      },
    },
  });
}

function handleSSE(req, core, ip) {
  const url = new URL(req.url);
  const channels = url.searchParams.get("channels")?.split(",") || [];

  if (channels.length === 0) {
    return new Response("Missing channels parameter", { status: 400 });
  }

  const lastEventId = req.headers.get("Last-Event-ID") || undefined;
  const { client, response } = core.sse.addClient({ lastEventId });

  for (const channel of channels) {
    core.sse.subscribe(client.id, channel);
  }

  req.signal.addEventListener("abort", () => {
    core.sse.removeClient(client.id);
  });

  const headers = new Headers(response.headers);
  const corsHeaders = getCorsHeaders();
  Object.entries(corsHeaders).forEach(([k, v]) => headers.set(k, v));

  return new Response(response.body, {
    status: response.status,
    headers,
  });
}

function extractClientIP(req, socketIP) {
  return (
    req.headers.get("x-forwarded-for")?.split(",")[0]?.trim() ||
    req.headers.get("x-real-ip") ||
    socketIP ||
    "127.0.0.1"
  );
}

function getCorsHeaders() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
  };
}
`;
}

// Re-export types
export type { AdapterOptions as Options };
