/**
 * Swift code generation utilities
 *
 * Functions that emit Swift source code strings for Package.swift,
 * ApiClient, Routes, models, and per-namespace extensions.
 */

import {
  toPascalCase,
  toCamelCase,
  groupRoutesByPrefix,
  type RouteInfo,
} from "@donkeylabs/server/generator";
import { zodToSwift, type SwiftTypeContext } from "./zod-to-swift.js";

// ==========================================
// Package.swift
// ==========================================

export function generatePackageSwift(
  packageName: string,
  platforms: Record<string, string>
): string {
  const platformLines = Object.entries(platforms)
    .map(([name, version]) => {
      const major = version.split(".")[0];
      const minor = version.split(".")[1];
      const versionSuffix = minor && minor !== "0" ? `${major}_${minor}` : `${major}`;
      return `        .${name}(.v${versionSuffix})`;
    })
    .join(",\n");

  return `// swift-tools-version: 5.9
// Auto-generated by @donkeylabs/adapter-swift
// DO NOT EDIT MANUALLY

import PackageDescription

let package = Package(
    name: "${packageName}",
    platforms: [
${platformLines}
    ],
    products: [
        .library(
            name: "${packageName}",
            targets: ["${packageName}"]
        ),
    ],
    targets: [
        .target(
            name: "${packageName}"
        ),
    ]
)
`;
}

// ==========================================
// Routes.swift (namespace constants)
// ==========================================

export function generateRoutesNamespace(routes: RouteInfo[]): string {
  const lines: string[] = [
    "// Auto-generated by @donkeylabs/adapter-swift",
    "// DO NOT EDIT MANUALLY",
    "",
    "import Foundation",
    "",
    "/// Route name constants for type-safe API calls",
    "public enum Routes {",
  ];

  const groups = groupRoutesByPrefix(routes);
  for (const [prefix, prefixRoutes] of groups) {
    const nsName = prefix === "_root" ? "Root" : toPascalCase(prefix);
    lines.push(`    public enum ${nsName} {`);
    for (const route of prefixRoutes) {
      const methodName = toCamelCase(route.routeName);
      lines.push(`        public static let ${methodName} = "${route.name}"`);
    }
    lines.push("    }");
  }

  lines.push("}");
  lines.push("");
  return lines.join("\n");
}

// ==========================================
// ApiClient.swift
// ==========================================

export function generateApiClient(packageName: string, apiVersion?: string): string {
  return `// Auto-generated by @donkeylabs/adapter-swift
// DO NOT EDIT MANUALLY

import Foundation

/// Typed API client for ${packageName}
public final class ApiClient: ApiClientBase, @unchecked Sendable {

    public let apiVersion: String?

    public init(baseURL: URL, apiVersion: String? = ${apiVersion ? `"${apiVersion}"` : "nil"}) {
        self.apiVersion = apiVersion
        super.init(baseURL: baseURL)
    }

    override func buildRequest(route: String, method: String, body: Data?, headers: [String: String]) -> URLRequest {
        var request = super.buildRequest(route: route, method: method, body: body, headers: headers)
        if let version = apiVersion {
            request.setValue(version, forHTTPHeaderField: "X-API-Version")
        }
        return request
    }
}
`;
}

// ==========================================
// ApiClient+Routes.swift (per-namespace extensions)
// ==========================================

export function generateApiClientExtensions(routes: RouteInfo[]): string {
  const lines: string[] = [
    "// Auto-generated by @donkeylabs/adapter-swift",
    "// DO NOT EDIT MANUALLY",
    "",
    "import Foundation",
    "",
  ];

  const groups = groupRoutesByPrefix(routes);

  for (const [prefix, prefixRoutes] of groups) {
    const nsName = prefix === "_root" ? "Root" : toPascalCase(prefix);

    lines.push(`// MARK: - ${nsName}`);
    lines.push("");
    lines.push("extension ApiClient {");

    for (const route of prefixRoutes) {
      const methodName = toCamelCase(route.routeName);
      const routePascal = toPascalCase(route.routeName);
      const routeConstant = `Routes.${nsName}.${methodName}`;

      switch (route.handler) {
        case "typed": {
          const inputType = route.inputSource ? `${routePascal}Input` : "EmptyInput";
          const outputType = route.outputSource ? `${routePascal}Output` : "AnyCodable";
          if (route.inputSource) {
            lines.push(`    public func ${methodName}(_ input: ${inputType}) async throws -> ${outputType} {`);
            lines.push(`        try await request(route: ${routeConstant}, input: input)`);
          } else {
            lines.push(`    public func ${methodName}() async throws -> ${outputType} {`);
            lines.push(`        try await request(route: ${routeConstant}, input: EmptyInput())`);
          }
          lines.push("    }");
          lines.push("");
          break;
        }
        case "raw": {
          lines.push(`    public func ${methodName}(method: String = "POST", body: Data? = nil, headers: [String: String] = [:]) async throws -> (Data, HTTPURLResponse) {`);
          lines.push(`        try await rawRequest(route: ${routeConstant}, method: method, body: body, headers: headers)`);
          lines.push("    }");
          lines.push("");
          break;
        }
        case "stream": {
          const inputType = route.inputSource ? `${routePascal}Input` : "EmptyInput";
          if (route.inputSource) {
            lines.push(`    public func ${methodName}(_ input: ${inputType}) async throws -> (URLSession.AsyncBytes, HTTPURLResponse) {`);
            lines.push(`        try await streamRequest(route: ${routeConstant}, input: input)`);
          } else {
            lines.push(`    public func ${methodName}() async throws -> (URLSession.AsyncBytes, HTTPURLResponse) {`);
            lines.push(`        try await streamRequest(route: ${routeConstant}, input: EmptyInput())`);
          }
          lines.push("    }");
          lines.push("");
          break;
        }
        case "sse": {
          const inputType = route.inputSource ? `${routePascal}Input` : "EmptyInput";
          if (route.inputSource) {
            lines.push(`    public func ${methodName}(_ input: ${inputType}) -> SSEConnection {`);
            lines.push(`        sseConnect(route: ${routeConstant}, input: input)`);
          } else {
            lines.push(`    public func ${methodName}() -> SSEConnection {`);
            lines.push(`        sseConnect(route: ${routeConstant}, input: EmptyInput())`);
          }
          lines.push("    }");
          lines.push("");
          break;
        }
        case "formData": {
          const inputType = route.inputSource ? `${routePascal}Input` : "EmptyInput";
          const outputType = route.outputSource ? `${routePascal}Output` : "AnyCodable";
          lines.push(`    public func ${methodName}(fields: ${inputType}, files: [(name: String, filename: String, mimeType: String, data: Data)]) async throws -> ${outputType} {`);
          lines.push(`        try await formDataRequest(route: ${routeConstant}, fields: fields, files: files)`);
          lines.push("    }");
          lines.push("");
          break;
        }
        case "html": {
          const inputType = route.inputSource ? `${routePascal}Input` : "EmptyInput";
          if (route.inputSource) {
            lines.push(`    public func ${methodName}(_ input: ${inputType}) async throws -> String {`);
            lines.push(`        try await htmlRequest(route: ${routeConstant}, input: input)`);
          } else {
            lines.push(`    public func ${methodName}() async throws -> String {`);
            lines.push(`        try await htmlRequest(route: ${routeConstant}, input: EmptyInput())`);
          }
          lines.push("    }");
          lines.push("");
          break;
        }
      }
    }

    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

// ==========================================
// Model files (one per namespace)
// ==========================================

export interface ModelGenerationResult {
  fileName: string;
  content: string;
}

export function generateModelFile(
  prefix: string,
  prefixRoutes: RouteInfo[]
): ModelGenerationResult | null {
  const nsName = prefix === "_root" ? "Root" : toPascalCase(prefix);

  const modelParts: string[] = [
    "// Auto-generated by @donkeylabs/adapter-swift",
    "// DO NOT EDIT MANUALLY",
    "",
    "import Foundation",
    "",
  ];

  let hasContent = false;

  for (const route of prefixRoutes) {
    const routePascal = toPascalCase(route.routeName);

    if (route.handler === "raw") continue;

    // Generate input type
    if (route.inputSource) {
      const inputContext: SwiftTypeContext = {
        namespace: nsName,
        declarations: [],
        currentTypeName: `${routePascal}Input`,
      };
      const result = zodToSwift(route.inputSource, inputContext);
      for (const decl of result.auxiliaryDeclarations) {
        modelParts.push(decl.code);
        modelParts.push("");
        hasContent = true;
      }
      if (result.inlineType !== `${routePascal}Input`) {
        if (!result.auxiliaryDeclarations.some((d) => d.name === `${routePascal}Input`)) {
          modelParts.push(`public typealias ${routePascal}Input = ${result.inlineType}`);
          modelParts.push("");
          hasContent = true;
        }
      }
    }

    // Generate output type
    if (route.outputSource && route.handler !== "stream" && route.handler !== "html" && route.handler !== "sse") {
      const outputContext: SwiftTypeContext = {
        namespace: nsName,
        declarations: [],
        currentTypeName: `${routePascal}Output`,
      };
      const result = zodToSwift(route.outputSource, outputContext);
      for (const decl of result.auxiliaryDeclarations) {
        modelParts.push(decl.code);
        modelParts.push("");
        hasContent = true;
      }
      if (result.inlineType !== `${routePascal}Output`) {
        if (!result.auxiliaryDeclarations.some((d) => d.name === `${routePascal}Output`)) {
          modelParts.push(`public typealias ${routePascal}Output = ${result.inlineType}`);
          modelParts.push("");
          hasContent = true;
        }
      }
    }

    // Generate SSE event types
    if (route.handler === "sse" && route.eventsSource) {
      const eventsParts: string[] = [];
      for (const [eventName, eventSchema] of Object.entries(route.eventsSource)) {
        const eventContext: SwiftTypeContext = {
          namespace: nsName,
          declarations: [],
          currentTypeName: `${routePascal}${toPascalCase(eventName)}Event`,
        };
        const result = zodToSwift(eventSchema, eventContext);
        for (const decl of result.auxiliaryDeclarations) {
          modelParts.push(decl.code);
          modelParts.push("");
        }
        eventsParts.push(`    case ${toCamelCase(eventName)} = "${eventName}"`);
      }
      if (eventsParts.length > 0) {
        modelParts.push(`public enum ${routePascal}EventType: String, Codable, Sendable {`);
        modelParts.push(...eventsParts);
        modelParts.push("}");
        modelParts.push("");
        hasContent = true;
      }
    }
  }

  if (!hasContent) return null;

  return {
    fileName: `${nsName}Models.swift`,
    content: modelParts.join("\n"),
  };
}
