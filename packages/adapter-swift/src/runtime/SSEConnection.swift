// Auto-generated by @donkeylabs/adapter-swift
// DO NOT EDIT MANUALLY

import Foundation

/// Server-Sent Events connection with typed event handling and auto-reconnect
public final class SSEConnection: @unchecked Sendable {
    private let request: URLRequest
    private let session: URLSession
    private var task: URLSessionDataTask?
    private var handlers: [String: (Data) -> Void] = [:]
    private var errorHandler: ((Error) -> Void)?
    private var reconnectHandler: (() -> Void)?
    private var isConnected = false
    private var shouldReconnect = true
    private var reconnectDelay: TimeInterval = 1.0
    private let maxReconnectDelay: TimeInterval = 30.0
    private var lastEventId: String?

    init(request: URLRequest, session: URLSession) {
        self.request = request
        self.session = session
    }

    deinit {
        disconnect()
    }

    // MARK: - Event Handlers

    /// Register a typed event handler
    public func on<T: Decodable>(_ event: String, handler: @escaping (T) -> Void) -> SSEConnection {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        handlers[event] = { data in
            if let decoded = try? decoder.decode(T.self, from: data) {
                handler(decoded)
            }
        }
        return self
    }

    /// Register a raw data event handler
    public func onRaw(_ event: String, handler: @escaping (Data) -> Void) -> SSEConnection {
        handlers[event] = handler
        return self
    }

    /// Register an error handler
    public func onError(_ handler: @escaping (Error) -> Void) -> SSEConnection {
        self.errorHandler = handler
        return self
    }

    /// Register a reconnect handler
    public func onReconnect(_ handler: @escaping () -> Void) -> SSEConnection {
        self.reconnectHandler = handler
        return self
    }

    // MARK: - Connection Management

    /// Start the SSE connection
    @discardableResult
    public func connect() -> SSEConnection {
        shouldReconnect = true
        startConnection()
        return self
    }

    /// Disconnect and stop reconnecting
    public func disconnect() {
        shouldReconnect = false
        isConnected = false
        task?.cancel()
        task = nil
    }

    // MARK: - Internal

    private func startConnection() {
        var req = request
        if let lastId = lastEventId {
            req.setValue(lastId, forHTTPHeaderField: "Last-Event-ID")
        }

        Task {
            do {
                let (bytes, response) = try await session.bytes(for: req)

                guard let httpResponse = response as? HTTPURLResponse,
                      (200..<300).contains(httpResponse.statusCode) else {
                    throw ApiError.invalidResponse
                }

                isConnected = true
                reconnectDelay = 1.0

                var currentEvent: String?
                var currentData = Data()

                for try await line in bytes.lines {
                    if line.isEmpty {
                        // End of event - dispatch
                        if !currentData.isEmpty {
                            let eventName = currentEvent ?? "message"
                            if let handler = handlers[eventName] {
                                handler(currentData)
                            }
                        }
                        currentEvent = nil
                        currentData = Data()
                        continue
                    }

                    if line.hasPrefix("event:") {
                        currentEvent = String(line.dropFirst(6)).trimmingCharacters(in: .whitespaces)
                    } else if line.hasPrefix("data:") {
                        let dataStr = String(line.dropFirst(5)).trimmingCharacters(in: .whitespaces)
                        if let data = dataStr.data(using: .utf8) {
                            if !currentData.isEmpty {
                                currentData.append("\n".data(using: .utf8)!)
                            }
                            currentData.append(data)
                        }
                    } else if line.hasPrefix("id:") {
                        lastEventId = String(line.dropFirst(3)).trimmingCharacters(in: .whitespaces)
                    } else if line.hasPrefix("retry:") {
                        if let ms = Double(String(line.dropFirst(6)).trimmingCharacters(in: .whitespaces)) {
                            reconnectDelay = ms / 1000.0
                        }
                    }
                }

                // Stream ended normally
                isConnected = false
                attemptReconnect()
            } catch {
                isConnected = false
                if shouldReconnect {
                    errorHandler?(error)
                    attemptReconnect()
                }
            }
        }
    }

    private func attemptReconnect() {
        guard shouldReconnect else { return }

        reconnectHandler?()

        Task {
            try? await Task.sleep(nanoseconds: UInt64(reconnectDelay * 1_000_000_000))
            guard shouldReconnect else { return }

            // Exponential backoff
            reconnectDelay = min(reconnectDelay * 2, maxReconnectDelay)
            startConnection()
        }
    }
}
