// Auto-generated by @donkeylabs/adapter-swift
// DO NOT EDIT MANUALLY

import Foundation

/// Empty input for routes that don't require parameters
public struct EmptyInput: Codable, Sendable {}

/// Base networking class using URLSession async/await
open class ApiClientBase {
    public let baseURL: URL
    private let session: URLSession
    private let encoder: JSONEncoder
    private let decoder: JSONDecoder

    public init(baseURL: URL, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.session = session
        self.encoder = JSONEncoder()
        self.encoder.dateEncodingStrategy = .iso8601
        self.decoder = JSONDecoder()
        self.decoder.dateDecodingStrategy = .iso8601
    }

    // MARK: - Request Building

    func buildRequest(route: String, method: String, body: Data?, headers: [String: String]) -> URLRequest {
        let url = baseURL.appendingPathComponent(route)
        var request = URLRequest(url: url)
        request.httpMethod = method
        request.httpBody = body
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }
        return request
    }

    // MARK: - Typed Request (POST JSON -> Decodable)

    public func request<Input: Encodable, Output: Decodable>(
        route: String,
        input: Input
    ) async throws -> Output {
        let body = try encoder.encode(input)
        let request = buildRequest(route: route, method: "POST", body: body, headers: [:])
        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw ApiError.invalidResponse
        }

        guard (200..<300).contains(httpResponse.statusCode) else {
            throw try parseErrorResponse(data: data, statusCode: httpResponse.statusCode)
        }

        return try decoder.decode(Output.self, from: data)
    }

    // MARK: - Raw Request

    public func rawRequest(
        route: String,
        method: String = "POST",
        body: Data? = nil,
        headers: [String: String] = [:]
    ) async throws -> (Data, HTTPURLResponse) {
        let request = buildRequest(route: route, method: method, body: body, headers: headers)
        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw ApiError.invalidResponse
        }

        return (data, httpResponse)
    }

    // MARK: - Stream Request

    public func streamRequest<Input: Encodable>(
        route: String,
        input: Input
    ) async throws -> (URLSession.AsyncBytes, HTTPURLResponse) {
        let body = try encoder.encode(input)
        let request = buildRequest(route: route, method: "POST", body: body, headers: [:])
        let (bytes, response) = try await session.bytes(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw ApiError.invalidResponse
        }

        guard (200..<300).contains(httpResponse.statusCode) else {
            // Collect the error body from the stream
            var errorData = Data()
            for try await byte in bytes {
                errorData.append(byte)
            }
            throw try parseErrorResponse(data: errorData, statusCode: httpResponse.statusCode)
        }

        return (bytes, httpResponse)
    }

    // MARK: - SSE Connect

    public func sseConnect<Input: Encodable>(
        route: String,
        input: Input
    ) -> SSEConnection {
        let body = try? encoder.encode(input)
        let request = buildRequest(route: route, method: "POST", body: body, headers: [
            "Accept": "text/event-stream",
            "Cache-Control": "no-cache",
        ])
        return SSEConnection(request: request, session: session)
    }

    // MARK: - Form Data Request (Multipart Upload)

    public func formDataRequest<Output: Decodable>(
        route: String,
        fields: Encodable,
        files: [(name: String, filename: String, mimeType: String, data: Data)]
    ) async throws -> Output {
        let boundary = "Boundary-\(UUID().uuidString)"
        var body = Data()

        // Encode fields as JSON, then add each top-level key as a form field
        let fieldsData = try encoder.encode(fields)
        if let fieldsDict = try JSONSerialization.jsonObject(with: fieldsData) as? [String: Any] {
            for (key, value) in fieldsDict {
                body.append("--\(boundary)\r\n".data(using: .utf8)!)
                body.append("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n".data(using: .utf8)!)
                body.append("\(value)\r\n".data(using: .utf8)!)
            }
        }

        // Add files
        for file in files {
            body.append("--\(boundary)\r\n".data(using: .utf8)!)
            body.append("Content-Disposition: form-data; name=\"\(file.name)\"; filename=\"\(file.filename)\"\r\n".data(using: .utf8)!)
            body.append("Content-Type: \(file.mimeType)\r\n\r\n".data(using: .utf8)!)
            body.append(file.data)
            body.append("\r\n".data(using: .utf8)!)
        }

        body.append("--\(boundary)--\r\n".data(using: .utf8)!)

        let url = baseURL.appendingPathComponent(route)
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.httpBody = body
        request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")

        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw ApiError.invalidResponse
        }

        guard (200..<300).contains(httpResponse.statusCode) else {
            throw try parseErrorResponse(data: data, statusCode: httpResponse.statusCode)
        }

        return try decoder.decode(Output.self, from: data)
    }

    // MARK: - HTML Request (returns String)

    public func htmlRequest<Input: Encodable>(
        route: String,
        input: Input
    ) async throws -> String {
        let body = try encoder.encode(input)
        let request = buildRequest(route: route, method: "POST", body: body, headers: [
            "Accept": "text/html",
        ])
        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw ApiError.invalidResponse
        }

        guard (200..<300).contains(httpResponse.statusCode) else {
            throw try parseErrorResponse(data: data, statusCode: httpResponse.statusCode)
        }

        guard let html = String(data: data, encoding: .utf8) else {
            throw ApiError.invalidResponse
        }

        return html
    }

    // MARK: - Error Parsing

    private func parseErrorResponse(data: Data, statusCode: Int) throws -> ApiError {
        struct ErrorBody: Decodable {
            let code: String?
            let message: String?
            let details: AnyCodable?
            let issues: [ValidationIssue]?
        }

        struct ValidationIssue: Decodable {
            let path: [String]?
            let message: String?
        }

        do {
            let errorBody = try decoder.decode(ErrorBody.self, from: data)

            if let issues = errorBody.issues {
                return .validation(issues: issues.map { issue in
                    ApiError.ValidationIssue(
                        path: issue.path ?? [],
                        message: issue.message ?? "Unknown validation error"
                    )
                })
            }

            return .server(
                status: statusCode,
                code: errorBody.code ?? "UNKNOWN",
                message: errorBody.message ?? "Unknown error",
                details: errorBody.details
            )
        } catch {
            return .server(
                status: statusCode,
                code: "UNKNOWN",
                message: String(data: data, encoding: .utf8) ?? "Unknown error",
                details: nil
            )
        }
    }
}

// MARK: - Encodable Helper

private extension Encodable {
    func encode(with encoder: JSONEncoder) throws -> Data {
        try encoder.encode(self)
    }
}
