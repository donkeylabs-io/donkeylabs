import { readdir, writeFile, readFile } from "node:fs/promises";
import { join } from "node:path";
import { stat } from "node:fs/promises";

// Extract handler names from plugin source files
async function extractHandlerNames(pluginPath: string): Promise<string[]> {
  try {
    const indexPath = join(pluginPath, "index.ts");
    const content = await readFile(indexPath, "utf-8");

    // Look for handlers: { ... } pattern in the plugin definition
    const handlersMatch = content.match(/handlers:\s*\{([^}]+)\}/);
    if (!handlersMatch || !handlersMatch[1]) return [];

    // Extract handler names (keys before the colon)
    const handlersBlock = handlersMatch[1];
    const handlerNames = [...handlersBlock.matchAll(/(\w+)\s*:/g)]
      .map(m => m[1])
      .filter((name): name is string => !!name);
    return handlerNames;
  } catch (e) {
    return [];
  }
}

// Extract middleware names from plugin source files
async function extractMiddlewareNames(pluginPath: string): Promise<string[]> {
  try {
    const indexPath = join(pluginPath, "index.ts");
    const content = await readFile(indexPath, "utf-8");

    // Look for middleware: { ... } pattern in the plugin definition
    const middlewareMatch = content.match(/middleware:\s*\{([^}]+)\}/);
    if (!middlewareMatch || !middlewareMatch[1]) return [];

    // Extract middleware names (keys before the colon)
    const middlewareBlock = middlewareMatch[1];
    const middlewareNames = [...middlewareBlock.matchAll(/(\w+)\s*:/g)]
      .map(m => m[1])
      .filter((name): name is string => !!name);
    return middlewareNames;
  } catch (e) {
    return [];
  }
}

async function main() {
  console.log("Generating Plugin Registry...");

  const pluginsDir = join(process.cwd(), "plugins");
  let pluginDirs: string[] = [];

  try {
      pluginDirs = await readdir(pluginsDir);
  } catch (e) {
      console.error("Directory plugins/ not found.");
      process.exit(1);
  }

  const foundPlugins: { name: string, import: string, handlers: string[], middleware: string[] }[] = [];

  for (const pluginName of pluginDirs) {
    const pluginPath = join(pluginsDir, pluginName);
    const stats = await stat(pluginPath);

    if (!stats.isDirectory()) continue;

    // Convention: plugin export is {name}Plugin, e.g. authPlugin
    const handlers = await extractHandlerNames(pluginPath);
    const middleware = await extractMiddlewareNames(pluginPath);
    foundPlugins.push({ name: pluginName, import: `${pluginName}Plugin`, handlers, middleware });
  }

  const importLines = foundPlugins.map(p => `import { ${p.import} } from "./plugins/${p.name}";`).join("\n");

  // 1. Generate Plugin Registry (Service, Schema, Handlers, Dependencies, Middleware)
  const pluginRegistryEntries = foundPlugins.map(p => {
      return `    ${p.name}: Register<InferService<typeof ${p.import}>, InferSchema<typeof ${p.import}>, InferHandlers<typeof ${p.import}>, InferDependencies<typeof ${p.import}>, InferMiddleware<typeof ${p.import}>>;`;
  }).join("\n");

  // 2. Generate Handler Registry (Handlers)
  const handlerExtensions = foundPlugins.map(p => `InferHandlers<typeof ${p.import}>`).join(",\n    ");

  // 3. Generate Middleware Registry
  const middlewareExtensions = foundPlugins.map(p => `InferMiddleware<typeof ${p.import}>`).join(",\n    ");

  // 4. Collect all custom handlers with their plugin info
  const allCustomHandlers = foundPlugins.flatMap(p =>
    p.handlers.map(h => ({ plugin: p.import, handler: h }))
  );

  // 5. Collect all custom middleware with their plugin info
  const allCustomMiddleware = foundPlugins.flatMap(p =>
    p.middleware.map(m => ({ plugin: p.import, middleware: m }))
  );

  // 6. Generate IRouteBuilder interface augmentation for custom handlers
  const routeBuilderMethodAugmentations = allCustomHandlers.map(({ plugin, handler }) => {
    return `    /** Custom handler from ${plugin} */
    ${handler}(config: {
      handle: InferHandlers<typeof ${plugin}>["${handler}"]["__signature"];
    }): TRouter;`;
  }).join("\n");

  // 7. Generate IMiddlewareBuilder interface augmentation for custom middleware
  const middlewareBuilderMethodAugmentations = allCustomMiddleware.map(({ plugin, middleware }) => {
    return `    /** Middleware from ${plugin} */
    ${middleware}(config?: InferMiddleware<typeof ${plugin}>["${middleware}"]["__config"]): this;`;
  }).join("\n");

  // 8. Generate handler union type for reference
  const handlerUnion = allCustomHandlers.length > 0
    ? `"typed" | "raw" | ${allCustomHandlers.map(h => `"${h.handler}"`).join(" | ")}`
    : `"typed" | "raw"`;

  // 9. Generate middleware union type for reference
  const middlewareUnion = allCustomMiddleware.length > 0
    ? allCustomMiddleware.map(m => `"${m.middleware}"`).join(" | ")
    : "never";

  const content = `// Auto-generated by scripts/generate-registry.ts
import { type Register, type InferService, type InferSchema, type InferHandlers, type InferMiddleware, type InferDependencies } from "./core";
${importLines}

declare module "./core" {
  export interface PluginRegistry {
${pluginRegistryEntries}
  }

  export interface PluginHandlerRegistry extends
    // Merge all plugin handlers
    ${handlerExtensions || "{}"}
  {}

  export interface PluginMiddlewareRegistry extends
    // Merge all plugin middleware
    ${middlewareExtensions || "{}"}
  {}
}

// Union type for all available handlers
export type AvailableHandlers = ${handlerUnion};

// Union type for all available middleware
export type AvailableMiddleware = ${middlewareUnion};

// Augment IRouteBuilder interface with custom handler methods
declare module "./router" {
  export interface IRouteBuilder<TRouter> {
${routeBuilderMethodAugmentations}
  }

  export interface IMiddlewareBuilder<TRouter> {
${middlewareBuilderMethodAugmentations}
  }
}
`;

  await writeFile("registry.d.ts", content);
  console.log("Generated registry.d.ts");

  // Generate registry.ts for runtime method registration
  const handlerRegistrations = allCustomHandlers.map(({ plugin, handler }) => {
    return `// Register "${handler}" handler method from ${plugin}
(RouteBuilder.prototype as any).${handler} = function(config: any) {
  return this.addHandler("${handler}", config);
};`;
  }).join("\n\n");

  const middlewareRegistrations = allCustomMiddleware.map(({ plugin, middleware }) => {
    return `// Register "${middleware}" middleware method from ${plugin}
(MiddlewareBuilder.prototype as any).${middleware} = function(config: any = {}) {
  return this.addMiddleware("${middleware}", config);
};`;
  }).join("\n\n");

  const runtimeContent = `// Auto-generated by scripts/generate-registry.ts
// Runtime registration of custom handler and middleware methods
/// <reference path="./registry.d.ts" />
import { RouteBuilder, MiddlewareBuilder } from "./router";

// Handler registrations
${handlerRegistrations}

// Middleware registrations
${middlewareRegistrations}
`;

  await writeFile("registry.ts", runtimeContent);
  console.log("Generated registry.ts");

  // Log found handlers and middleware
  for (const p of foundPlugins) {
    const parts: string[] = [];
    if (p.handlers.length > 0) parts.push(`handlers [${p.handlers.join(", ")}]`);
    if (p.middleware.length > 0) parts.push(`middleware [${p.middleware.join(", ")}]`);
    if (parts.length > 0) {
      console.log(`  ${p.name}: ${parts.join(", ")}`);
    }
  }
}

main().catch(console.error);
