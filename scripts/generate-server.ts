import { writeFile, readdir, stat } from "node:fs/promises";
import { join } from "node:path";

async function main() {
  console.log("Generating Server Context...");

  // Find all plugins to generate schema intersection
  const pluginsDir = join(process.cwd(), "examples/basic-server/src/plugins");
  let pluginNames: string[] = [];

  try {
    const files = await readdir(pluginsDir);
    for (const f of files) {
      const pluginPath = join(pluginsDir, f);
      const stats = await stat(pluginPath);
      if (stats.isDirectory() && !f.startsWith(".")) {
        pluginNames.push(f);
      }
    }
  } catch (e) {
    // plugins dir might not exist
  }

  // Generate schema intersection: Schema1 & Schema2 & Schema3
  const schemaIntersection = pluginNames.length > 0
    ? pluginNames.map(p => `PluginRegistry["${p}"]["schema"]`).join(" & ")
    : "{}";

  const content = `
// Auto-generated by scripts/generate-server.ts
// Do not edit manually.

/// <reference path="./registry.d.ts" />
import type { PluginRegistry, CoreServices } from "./src/core";
import type { Errors } from "./src/core/errors";
import type { Kysely } from "kysely";

// Intersection of all plugin schemas - enables db.selectFrom("users"), db.selectFrom("posts"), etc.
type DatabaseSchema = ${schemaIntersection};

export interface GlobalContext {
  db: Kysely<DatabaseSchema>;
  plugins: {
    [K in keyof PluginRegistry]: PluginRegistry[K]["service"];
  };
  core: CoreServices;
  /** Convenience access to error factories - same as core.errors */
  errors: Errors;
  ip: string;
  requestId?: string;
  user?: any;
}
`;

  await writeFile(join(process.cwd(), "context.d.ts"), content);
  console.log("Generated context.d.ts");
  console.log(`  Merged schemas from: [${pluginNames.join(", ")}]`);
}

main().catch(console.error);
